
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/Evaluation.ipynb

import cv2
import time

import os, sys
# base = "/Users/ckh/Documents/Poladrone/nb"
base = "D:/YoloV5_Hui/poladrone_nb"
sys.path.append(base + "/ref/pytorchYOLOv4")

from exp.nb_TrainingRunnner import *
from exp.nb_LoggingModule import custom_init_logger
from config.config import Cfg

from ref.pytorchYOLOv4.tool.utils import nms_cpu, bbox_iou

def load_model(weight_path, n_classes=1):
    ## load model
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    print(f'Load: {weight_path} | Device: {device}')

    model = Yolov4(None, n_classes=n_classes, inference=True)
    model = torch.nn.DataParallel(model)
    model.load_state_dict(torch.load(weight_path, map_location=device))
    return model


def preprocess_image(img_raw, targetSize=416):
    img = cv2.resize(img_raw, (targetSize,targetSize))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = img.transpose(2, 0, 1)
    img = torch.from_numpy(img).div(255.0)
    img = img.unsqueeze(0)
    return img

def predict_img(model, img, size):
    img = preprocess_image(img, targetSize=size)
    out = model(img)
    return out

def post_processing(img, conf_thresh, nms_thresh, output):

    # anchors = [12, 16, 19, 36, 40, 28, 36, 75, 76, 55, 72, 146, 142, 110, 192, 243, 459, 401]
    # num_anchors = 9
    # anchor_masks = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
    # strides = [8, 16, 32]
    # anchor_step = len(anchors) // num_anchors

#     t1 = time.time()

    if type(output).__name__ != 'ndarray':
        output = output.cpu().detach().numpy()

    # [batch, num, 4]
    box_array = output[:, :, :4]

    # [batch, num, num_classes]
    confs = output[:, :, 4:]

    # [batch, num, num_classes] --> [batch, num]
    max_conf = np.max(confs, axis=2)
    max_id = np.argmax(confs, axis=2)

#     t2 = time.time()

    bboxes_batch = []
    for i in range(box_array.shape[0]):

        argwhere = max_conf[i] > conf_thresh
        l_box_array = box_array[i, argwhere, :]
        l_max_conf = max_conf[i, argwhere]
        l_max_id = max_id[i, argwhere]

        keep = nms_cpu(l_box_array, l_max_conf, nms_thresh)

        bboxes = []
        if (keep.size > 0):
            l_box_array = l_box_array[keep, :]
            l_max_conf = l_max_conf[keep]
            l_max_id = l_max_id[keep]

            for j in range(l_box_array.shape[0]):
                bboxes.append([l_box_array[j, 0], l_box_array[j, 1], l_box_array[j, 2], l_box_array[j, 3], l_max_conf[j], l_max_conf[j], l_max_id[j]])

        bboxes_batch.append(bboxes)

#     t3 = time.time()

#     print('-----------------------------------')
#     print('       max and argmax : %f' % (t2 - t1))
#     print('                  nms : %f' % (t3 - t2))
#     print('Post processing total : %f' % (t3 - t1))
#     print('-----------------------------------')

    return bboxes_batch


def bbox_iogt(box1, box2, x1y1x2y2=True):
    '''
    box1: GT
    '''

    # print('iou box1:', box1)
    # print('iou box2:', box2)

    if x1y1x2y2:
        mx = min(box1[0], box2[0])
        Mx = max(box1[2], box2[2])
        my = min(box1[1], box2[1])
        My = max(box1[3], box2[3])
        w1 = box1[2] - box1[0]
        h1 = box1[3] - box1[1]
        w2 = box2[2] - box2[0]
        h2 = box2[3] - box2[1]
    else:
        w1 = box1[2]
        h1 = box1[3]
        w2 = box2[2]
        h2 = box2[3]

        mx = min(box1[0], box2[0])
        Mx = max(box1[0] + w1, box2[0] + w2)
        my = min(box1[1], box2[1])
        My = max(box1[1] + h1, box2[1] + h2)
    uw = Mx - mx
    uh = My - my
    cw = w1 + w2 - uw
    ch = h1 + h2 - uh
    carea = 0
    if cw <= 0 or ch <= 0:
        return 0.0

    area1 = w1 * h1
    area2 = w2 * h2
    carea = cw * ch
#     uarea = area1 + area2 - carea
    uarea = area1
    return carea / uarea


def score(gt, nms):
    if nms.size == 0:
        return 0, len(gt)

    box_gt = gt/1000

    x1 = nms[:,:,0] - nms[:,:,2]
    y1 = nms[:,:,1] - nms[:,:,3]
    x2 = nms[:,:,0] + nms[:,:,2]
    y2 = nms[:,:,1] + nms[:,:,3]
    box_predict = np.concatenate([x1,y1,x2,y2], axis=0).T

    iogt = [[bbox_iogt(g, p) for g in box_gt] for p in box_predict]
    iogt = np.max(iogt, axis=0)

    total = len(iogt)
    score = sum(iogt > 0.9)

    return score, total

def benchmark_size(size):

    pt = []
    count = []
    t = []
    for index in range(len(val_dataset)):
        print(index, end=" ")
        ## inference
        img_raw, gt = val_dataset[index]

        t1 = time.time()
        out = predict_img(model, img_raw, size)
        t2 = time.time()
        t.append(t2 - t1)

        ## NMS
        nms_box = post_processing(None, 0.01,0.5, out)
        nms = np.array(nms_box)

        p, c = score(gt, nms)
        pt.append(p)
        count.append(c)

    inference_time = np.mean(t)
    score_pre_img = (np.array(pt) / np.array(count)).mean()
    score_all = np.sum(pt) / np.sum(count)

    return inference_time, score_pre_img, score_all